
鼠标事件 // https://blog.csdn.net/weixin_37150764/article/details/109214855
Click、mousedown、mousemove、mouseup、contextmenu、mouseover、mouseout、mouseenter、mouseleave
用button来区分鼠标的按键，0/1/2

DOM3标准规定：click事件只能监听左键，只能通过mousedown和mouseup老判断鼠标键
鼠标事件：
拖拽应用：
应用mousedown mousemove mouseup
随机移动的方块
[Mousever]

键盘分类：
Keydown keyup keypress Keydown>keypress>keyup
Keydown>keypress>keyup Keydown和keypress的区别
Keydown可以响应任意键盘按键，keypress只可以响应字符串键盘按键 Keydown返回ASCII码，可以转换相应字符

文本操作事件：
Input,focus,blur,change 时间分类： 窗体操作（window上的事件） Scroll load

let a = ['click','mousedown','mousemove','mouseup','contextmenu','mouseover','mouseout','mouseenter','mouseleave','mousewheel'];
let c = ['click','mousedown','mousemove','contextmenu','mousewheel'];
let b = ['click','mousedown','mousemove','mousewheel']; //鼠标移动 点击 滚动
for (let s = 0; s < a.length; s++) {
      window.addEventListener(a[s],function (e) {
        console.log(a[s]+s+"鼠标",e);
      });
    }


vue中：鼠标滚轮事件 // https://blog.csdn.net/qq_54207312/article/details/124623370

@scroll="shonwinfor"

@wheel="showinfor"

前者针对的是窗口滚动条，当滚动条动作，就会执行相应的回调，它的特点是滚动条要在回调结束后才能动作，所以可以为其加一个passive修饰符，这样就可以达到类似异步执行的效果。

后者针对的是鼠标滚轮，只要鼠标滚轮动作，就会执行相应的回调



文件，通过拖拽上传事件 darg(e){ e.dataTransfer.files[0] } 获取
上传文件,formData为空，修改header为以下可上传；因默认formData被转为了空对象。打印需要用get方法
this.$axios({
          method:'POST',
          url:"https://xxx.xxx",
          header:{'Content-Type':"multipart/form-data"},
          data:formData
        }).then()


报错：
Cannot assign to read only property 'exports' of object '#<Object>'
原因 import a from './a.js' 
与module.exports={... 在webpack打包时，解析冲突。
可尝试 用export default {  替换 module.exports={...
或者引入插件  //   https://www.jianshu.com/p/837e6b7d0ce0
npm install babel-plugin-transform-es2015-modules-commonjs
然后在 babelrc中配置
{ "plugins": ["transform-es2015-modules-commonjs"] }
即可解决


css斜线 // https://blog.51cto.com/u_15309889/3172868?abTest=51cto
 background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"><line x1="0" y1="0" x2="100%" y2="100%" stroke="black" stroke-width="1"/></svg>');


vue3组件中引入其他js文件，可放到public文件夹，直接'demo.js'引入，不需要加 ./   //https://blog.csdn.net/weixin_43742708/article/details/110594790

vue强制组件重新渲染  // https://blog.51cto.com/u_15060508/3717478?abTest=51cto
简单粗暴的方式：重新加载整个页面
不妥的方式：使用 v-if
较好的方法：使用Vue的内置forceUpdate方法
最好的方法：在组件上进行 key 更改
